/**
 * Workflow Result Export Utilities
 *
 * Exports workflow run results to professional Word documents
 * Routes to workflow-specific exporters or generic exporter
 */

import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
  BorderStyle,
} from "docx";
import { exportInvestmentMemoAsWord } from "./exportInvestmentMemo";

/**
 * Export workflow result as professional Word document
 * Routes to workflow-specific exporters based on workflow name
 * @param {Object} artifact - Workflow artifact with sections
 * @param {Object} run - Workflow run metadata
 */
export async function exportWorkflowAsWord(artifact, run) {
  if (!artifact) {
    throw new Error("No workflow data to export");
  }

  // Route to workflow-specific exporters
  if (run?.workflow_name === "Investment Memo") {
    return exportInvestmentMemoAsWord(artifact.artifact, run);
  }

  // Generic export for other workflows
  return exportGenericWorkflowAsWord(artifact.artifact, run);
}

/**
 * Generic workflow export (for workflows without specific exporters)
 * @param {Object} artifact - Workflow artifact with sections
 * @param {Object} run - Workflow run metadata
 */
async function exportGenericWorkflowAsWord(artifact, run) {
  if (!artifact) {
    throw new Error("No workflow data to export");
  }

  const workflowName = run?.workflow_name || "Workflow";
  const dateStr = new Date(run?.created_at || Date.now()).toLocaleDateString();

  // Build document children
  const children = [
    // Cover Page
    new Paragraph({
      text: workflowName,
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 200 },
    }),

    new Paragraph({
      text: "Workflow Analysis Report",
      heading: HeadingLevel.HEADING_2,
      alignment: AlignmentType.CENTER,
      spacing: { after: 300 },
    }),

    new Paragraph({
      children: [
        new TextRun({
          text: `Generated: ${dateStr}`,
          bold: true,
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 100 },
    }),

    ...(run?.status === "completed"
      ? [
          new Paragraph({
            children: [
              new TextRun({
                text: "âœ“ Completed",
                bold: true,
                color: "059669", // success green
              }),
            ],
            alignment: AlignmentType.CENTER,
            spacing: { after: 300 },
          }),
        ]
      : []),

    // Divider
    new Paragraph({
      border: {
        bottom: {
          color: "CCCCCC",
          space: 1,
          style: BorderStyle.SINGLE,
          size: 12,
        },
      },
      spacing: { after: 400 },
    }),
  ];

  // Add all sections from artifact dynamically
  addAllSections(children, artifact);

  // Footer
  children.push(
    new Paragraph({
      border: {
        top: {
          color: "CCCCCC",
          space: 1,
          style: BorderStyle.SINGLE,
          size: 6,
        },
      },
      spacing: { before: 400, after: 200 },
    }),

    new Paragraph({
      children: [
        new TextRun({
          text: "Generated by Sand Cloud Document Intelligence",
          italics: true,
          size: 18,
          color: "6B7280",
        }),
      ],
      alignment: AlignmentType.CENTER,
    })
  );

  if (run?.duration_seconds) {
    children.push(
      new Paragraph({
        text: `Processing Time: ${run.duration_seconds}s`,
        alignment: AlignmentType.CENTER,
        spacing: { after: 50 },
      })
    );
  }

  // Create document
  const doc = new Document({
    sections: [
      {
        properties: {},
        children,
      },
    ],
  });

  // Generate and download
  const blob = await Packer.toBlob(doc);
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = sanitizeFilename(`${workflowName}_Report.docx`);
  a.click();
  URL.revokeObjectURL(url);
}

/**
 * Dynamically add all sections from the artifact
 */
function addAllSections(children, artifact) {
  // Handle structured sections array format
  if (artifact.sections && Array.isArray(artifact.sections)) {
    artifact.sections.forEach((section, index) => {
      // Section heading
      if (section.heading) {
        children.push(
          new Paragraph({
            text: section.heading,
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 300, after: 200 },
          })
        );
      }

      // Section content
      if (section.content) {
        addContent(children, section.content);
      }

      // Add spacing after section (except last)
      if (index < artifact.sections.length - 1) {
        children.push(
          new Paragraph({
            spacing: { after: 300 },
          })
        );
      }
    });
  }
  // Handle flat object format (all keys are sections)
  else if (typeof artifact === "object" && !Array.isArray(artifact)) {
    // Get all top-level keys as sections
    Object.entries(artifact).forEach(([key, value], index, arr) => {
      // Skip metadata fields
      if (key === "metadata" || key === "summary" || key === "created_at")
        return;

      // Add section heading
      children.push(
        new Paragraph({
          text: formatKeyName(key),
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 300, after: 200 },
        })
      );

      // Add content
      addContent(children, value);

      // Add spacing after section (except last)
      if (index < arr.length - 1) {
        children.push(
          new Paragraph({
            spacing: { after: 300 },
          })
        );
      }
    });
  }
  // Handle string format (just add as content)
  else if (typeof artifact === "string") {
    addContent(children, artifact);
  }
}

/**
 * Add content based on its type
 */
function addContent(children, content) {
  if (!content) return;

  // Handle string content
  if (typeof content === "string") {
    const paragraphs = content.split("\n\n");
    paragraphs.forEach((para) => {
      if (para.trim()) {
        children.push(
          new Paragraph({
            text: para.trim(),
            spacing: { after: 150 },
          })
        );
      }
    });
  }
  // Handle array content
  else if (Array.isArray(content)) {
    content.forEach((item, index) => {
      if (typeof item === "string") {
        children.push(
          new Paragraph({
            text: `${index + 1}. ${item}`,
            spacing: { after: 100 },
            bullet: { level: 0 },
          })
        );
      } else if (typeof item === "object") {
        // Object items - show as key-value pairs
        addObjectContent(children, item);
      }
    });
  }
  // Handle object content
  else if (typeof content === "object") {
    addObjectContent(children, content);
  }
  // Handle other types
  else {
    children.push(
      new Paragraph({
        text: String(content),
        spacing: { after: 150 },
      })
    );
  }
}

/**
 * Add object content as key-value pairs
 */
function addObjectContent(children, obj) {
  if (!obj || typeof obj !== "object") return;

  Object.entries(obj).forEach(([key, value]) => {
    if (value === null || value === undefined || value === "") return;

    // Format the value
    let displayValue;
    if (typeof value === "object" && !Array.isArray(value)) {
      displayValue = JSON.stringify(value, null, 2);
    } else if (Array.isArray(value)) {
      displayValue = value.join(", ");
    } else {
      displayValue = String(value);
    }

    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `${formatKeyName(key)}: `,
            bold: true,
          }),
          new TextRun({
            text: displayValue,
          }),
        ],
        spacing: { after: 100 },
      })
    );
  });
}

/**
 * Format key name for display
 */
function formatKeyName(key) {
  return key.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
}

/**
 * Sanitize filename for safe download
 */
function sanitizeFilename(filename) {
  return filename
    .replace(/[^a-z0-9.-]/gi, "_")
    .replace(/_+/g, "_")
    .substring(0, 50)
    .toLowerCase();
}
